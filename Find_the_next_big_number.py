def solution(numbers):
    answer = [-1] * len(numbers)  # 기본값을 -1로 초기화
    stack = []  # 스택 초기화

    for i in range(len(numbers)):
        while stack and numbers[i] > numbers[stack[-1]]:
            index = stack.pop()
            answer[index] = numbers[i]  # 더 큰 숫자를 찾았으므로 업데이트
        stack.append(i)  # 현재 숫자의 인덱스를 스택에 추가
    return answer


#1) 문제 설명

'''정수로 이루어진 배열 numbers가 있다. 배열 의 각 원소들에 대해 자신보다 뒤에 있는 숫자 중에서 자신보다 크면서 가장 가까이 있는 수를 뒷 큰수라고 한다.
정수 배열 numbers가 매개변수로 주어질 때, 모든 원소에 대한 뒷 큰수들을 차례로 담은 배열을 반환하도록 solution 함수를 완성해라. 단, 뒷 큰수가 존재하지 않는 원소는 -1을 담는다.
'''
#2) 제한 사항

'''4 ≤ numbers의 길이 ≤ 1,000,000
1 ≤ numbers[i] ≤ 1,000,000'''

#3) 입출력 예시 

'''입출력 예 #1



numbers가 [2, 3, 3, 5]이면,

2의 뒷 큰수는 3이다.

첫 번째 3의 뒷 큰수는 5이다.

두 번째 3 또한 마찬가지이다.

5는 뒷 큰수가 없으므로 -1이다.

위 수들을 차례대로 배열에 담으면 [3, 5, 5, -1]이 된다.



입출력 예 #2



numbers가 [9, 1, 5, 3, 6, 2]이면,

9는 뒷 큰수가 없으므로 -1이다.

1의 뒷 큰수는 5이며, 5와 3의 뒷 큰수는 6이다.

6과 2는 뒷 큰수가 없으므로 -1이다.

위 수들을 차례대로 배열에 담으면 [-1, 5, 6, 6, -1, -1]이 된다.'''

#4) 코드 설명

'''solution 함수에 numbers의 값을 입력 받는다.
answer 리스트는 모든 값을 기본값 -1로 초기화하여, 각 숫자에 대해 "다음 큰 숫자"가 없을 경우를 대비한다.
인덱스를 저장하기 위해 stack이라는 빈 리스트를 만든다.
for문을 통해 i에 0부터 numbers의 길이 빼기 1까지 하나씩 숫자를 삽입한다.
for문 안에서는 while문을 통해 stack이 비어 있지 않고 인덱스 위치가 i번째인 숫자가 stack의 저장된 인덱스 값 위치의 numbers의 요소 값보다 큰 경우에만 실행한다.
while문 안에서는 index에 stack 리스트의 마지막 요소를 가져와 저장하고 stack 리스트에서 삭제한다.
그런 다음 answer에 해당 인덱스 위치의 값을 numbers의 인덱스 i번째 값으로 업데이트한다.
while문이 끝나면 stack에 해당 인덱스 값을 추가한다.
모든 코드가 끝나면 answer 값을 반환한다.'''

#문제 출처 : 프로그래머스
