def solution(X, Y):
    partner = []
    a = list(set(X))
    for i in a:
        if i in Y:
            m = min(X.count(i),Y.count(i))
            for j in range(m):
                partner.append(i)
    partner = sorted(partner,reverse = True)
    if len(partner) > 0 :
        answer = "".join(map(str,partner))
        if answer.replace("0", '') == '':
            answer = "0"
    else:
        answer = "-1"        
    return answer

#1) 문제 설명

'''두 정수 X, Y의 임의의 자리에서 공통으로 나타나는 정수 k(0 ≤ k ≤ 9)들을 이용하여 만들 수 있는 가장 큰 정수를 두 수의 짝꿍이라 한다(단, 공통으로 나타나는 정수 중 서로 짝지을 수 있는 숫자만 사용한다). X, Y의 짝꿍이 존재하지 않으면, 짝꿍은 -1이다. X, Y의 짝꿍이 0으로만 구성되어 있다면, 짝꿍은 0이다.
예를 들어, X = 3403이고 Y = 13203이라면, X와 Y의 짝꿍은 X와 Y에서 공통으로 나타나는 3, 0, 3으로 만들 수 있는 가장 큰 정수인 330이다. 다른 예시로 X = 5525이고 Y = 1255이면 X와 Y의 짝꿍은 X와 Y에서 공통으로 나타나는 2, 5, 5로 만들 수 있는 가장 큰 정수인 552이다(X에는 5가 3개, Y에는 5가 2개 나타나므로 남는 5 한 개는 짝 지을 수 없다.)
두 정수 X, Y가 주어졌을 때, X, Y의 짝꿍을 return하는 solution 함수를 완성해라.'''

#2) 제한 사항

'''3 ≤ X, Y의 길이(자릿수) ≤ 3,000,000이다.
X, Y는 0으로 시작하지 않는다.
X, Y의 짝꿍은 상당히 큰 정수일 수 있으므로, 문자열로 반환한다.'''

#3) 입출력 예시



'''입출력 예 #1

X가 "100"이고 Y가 "2345"이면 X, Y의 짝꿍은 존재하지 않는다. 따라서 "-1"을 반환한다.


입출력 예 #2

X가 "100"이고 Y가 "203045"이면 X, Y의 공통된 숫자는 0으로만 구성되어 있기 때문에, 두 수의 짝꿍은 정수 0이다. 따라서 "0"을 반환한다.
입출력 예 #3

X가 "100"이고 Y가 "123450"이면 X, Y의 짝꿍은 10이므로, "10"을 반환한다.
입출력 예 #4

X가 "12321"이고 Y가 "42531"이면 X, Y의 짝꿍은 321이다. 따라서 "321"을 반환한다.'''

#4) 코드 설명

'''solution 함수에서 X, Y의 값을 입력 받는다.
짝궁인 숫자를 찾기 위해 panter이라는 빈 리스트를 만든다.
set 함수를 이용하여 X를 집합으로 만들어 중복을 없애고 list 함수로 리스트로 만든다.
반복문을 통해 i에다가 리스트 a 값을 집어넣는다.
만약 해당 i값이 Y에 있다면 그 숫자는 짝궁이므로 X와 Y에서 그 숫자를 가지고 있는 개수가 더 적은 쪽을 m에 저장한다.
그 후 m의 크기만큼 반복문을 하여 panter 리스트에 추가한다.
모든 반복문이 끝나면 sorted 함수를 이용하여 partner 리스트를 내림차순으로 정렬해준다.
만약 panter의 길이가 0보다 크다면, 즉 하나 이상의 짝궁인 숫자가 있다면 map 함수를 이용해 partner 리스트의 요소 값들을 모두 문자형으로 바꾼 후 join함수를 이용해 문자열 형태로 바꾸어 answer에 저장한다.
만약 replace 함수를 이용해서 "0"의 값을 빈 상태로 바꾸었을 때 문자열 전체가 빈 상태가 된다면, 즉 0으로만 이루어 져 있다면 answer의 값을 "0"으로 한 상태로 만든다.
만약 parnter의 길이가 0보다 크지 않다면 짝궁인 수가 없는 것이므로 answer의 값을 "-1"로 저장한다.
그 후 answer의 값을 반환한다.'''

#문제 출처 : 프로그래머스