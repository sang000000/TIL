def solution(elements):
    answer = elements + [sum(elements)]
    double_elements = elements * 2
    for i in range(2, len(elements)):
        for j in range(0, len(elements)):
            answer.append(sum(double_elements[j : i + j]))
    answer = set(answer)
    return len(answer)


# 1) 문제 설명

"""철호는 수열을 가지고 놀기 좋아한다. 어느 날 철호는 어떤 자연수로 이루어진 원형 수열의 연속하는 부분 수열의 합으로 만들 수 있는 수가 모두 몇 가지인지 알아보고 싶어졌다. 원형 수열이란 일반적인 수열에서 처음과 끝이 연결된 형태의 수열을 말한다. 예를 들어 수열 [7, 9, 1, 1, 4] 로 원형 수열을 만들면 다음과 같다.

원형 수열은 처음과 끝이 연결되어 끊기는 부분이 없기 때문에 연속하는 부분 수열도 일반적인 수열보다 많아진다.
원형 수열의 모든 원소 elements가 순서대로 주어질 때, 원형 수열의 연속 부분 수열 합으로 만들 수 있는 수의 개수를 반환하도록 solution 함수를 완성해라."""

# 2) 제한 사항

"""3 ≤ elements의 길이 ≤ 1,000
1 ≤ elements의 원소 ≤ 1,000"""


# 3) 입출력 예시


"""입출력 예 #1

 

elements가 [7,9,1,1,4]이면, 길이가 1인 연속 부분 수열로부터 [1, 4, 7, 9] 네 가지의 합이 나올 수 있다.
길이가 2인 연속 부분 수열로부터 [2, 5, 10, 11, 16] 다섯 가지의 합이 나올 수 있다.
길이가 3인 연속 부분 수열로부터 [6, 11, 12, 17, 20] 다섯 가지의 합이 나올 수 있다.
길이가 4인 연속 부분 수열로부터 [13, 15, 18, 21] 네 가지의 합이 나올 수 있다.
길이가 5인 연속 부분 수열로부터 [22] 한 가지의 합이 나올 수 있다.
이들 중 중복되는 값을 제외하면 다음과 같은 18가지의 수들을 얻는다.
[1, 2, 4, 5, 6, 7, 9, 10, 11, 12, 13, 15, 16, 17, 18, 20, 21, 22]"""

# 4) 코드 설명

"""solution 함수에서 elements의 값을 입력 받는다.
answer은 부분 수열의 합을 구하기 위해 길이가 1인 연속 부분 수열의 각 합은 elements 리스트의 값과 같으므로 과 길이가 elements의 길이와 같은 연속 부분 수열의 합은 elements 리스트의 요소 값과 같으므로 초기에 두 값을 저장한다.
길이가 n인 연속 부분 수열의 각 합을 구하기 위해 double_elements에 elements 리스트의 요소를 2배로 복사하여 저장한다.
반복문에서는 i에 2부터 elements의 길이 전까지 i에 할당한다.
반복문 안에 반복문에서는 j에 0부터 elements 길이 전까지 j에 할당한다.
반복문 안에 반복문에서는 answer 리스트에 double_elements에 j부터 j+i 전까지 인덱스 위치의 값을 가져와 sum 함수로 더해서 연속 부분 수열의 합을 구해서 추가한다.
모든 반복문이 끝나면 중복을 제거하기 위해 set 함수를 사용한다.
그 후 answer의 길이를 반환한다. """

# 문제 출처 : 프로그래머스
