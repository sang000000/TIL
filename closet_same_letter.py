def solution(s):
    answer = [-1]
    c = 0
    for i in range(1,len(s)):
        for j in range(i):
            if s[j] == s[i]:
                c = i-j
        if c > 0:
            answer.append(c)
        if c == 0:
            answer.append(-1)
        c = 0
    return answer


#1) 문제 설명

'''문자열 s가 주어졌을 때, s의 각 위치마다 자신보다 앞에 나왔으면서, 자신과 가장 가까운 곳에 있는 같은 글자가 어디 있는지 알고 싶다.
예를 들어, s="banana"라고 할 때,  각 글자들을 왼쪽부터 오른쪽으로 읽어 나가면서 다음과 같이 진행할 수 있다.
b는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현한다.
a는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현한다.
n은 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현한다.
a는 자신보다 두 칸 앞에 a가 있습니다. 이는 2로 표현한다.
n도 자신보다 두 칸 앞에 n이 있습니다. 이는 2로 표현한다.
a는 자신보다 두 칸, 네 칸 앞에 a가 있다. 이 중 가까운 것은 두 칸 앞이고, 이는 2로 표현한다.
따라서 최종 결과물은 [-1, -1, -1, 2, 2, 2]가 된다.
문자열 s이 주어질 때, 위와 같이 정의된 연산을 수행하는 함수 solution을 완성해라.'''

#2) 제한 사항.

'''1 ≤ s의 길이 ≤ 10,000
s은 영어 소문자로만 이루어져 있다.'''

#3) 입출력 예시

'''입출력 예 #1

s가 "banana"이면, [-1, -1, -1, 2, 2, 2]을 return한다.

입출력 예 #2

s가 "foobar"이면, [-1, -1, 1, -1, -1, -1]을 return한다.'''

#4) 코드 설명

'''solution 함수에서 s의 값을 입력 받는다.
첫 알파벳은 앞에 글자 자체가 없으므로 -1을 요소로 가지고 있는 answer 리스트를 만든다.
위치를 찾기 위해 c는 초기 값을 0으로 준다.
이중 반복문을 통해 i는 1부터 s의 길이 배끼 1까지 하니씩 증가시키고 j는 0부터 i값 빼기 1까지 하나씩 증가시킨다.
만약 문자열 s의 j-1번째 위치의 값이 i-1번째 위치의 값과 같다면, i-1번째 문자보다 얼마나 앞에 위치하는 지 알기 위해 i - j를 해서 구한다.
j 반복문이 끝나면 그때 c의 값에 따라 0보다 크면 같은 값이 있다는 의미이므로 c의 값을 answer 리스트에 추가하고 그대로 0이라면 -1을 answer 리스트에 추가한다.
모든 반복문이 끝나면 answer 리스트를 반환한다. '''

#문제 출처 : 프로그래머스