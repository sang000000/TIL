def solution(nums):
    answer = 0
    for i in range(len(nums)-2):
        for j in range(i+1,len(nums)-1):
            for k in range(j+1,len(nums)):
                for q in range(2,nums[i]+nums[j]+nums[k]):
                    
                    if (nums[i]+nums[j]+nums[k]) % q == 0:
                        break                                     
                else:
                    answer+= 1                
    return answer


#1) 문제 설명

'주어진 숫자 중 3개의 수를 더했을 때 소수가 되는 경우의 개수를 구하려고 한다. 숫자들이 들어있는 배열 nums가 매개변수로 주어질 때, nums에 있는 숫자들 중 서로 다른 3개를 골라 더했을 때 소수가 되는 경우의 개수를 return 하도록 solution 함수를 완성해라.'

#2) 제한 사항

'''nums에 들어있는 숫자의 개수는 3개 이상 50개 이하이다.
nums의 각 원소는 1 이상 1,000 이하의 자연수이며, 중복된 숫자가 들어있지 않다.'''

#) 입출력 예시



'''입출력 예 #1

nums가 [1,2,3,4]이면, [1,2,4]를 이용해서 7을 만들 수 있으므로 1을 반환한다.


입출력 예 #2

nums가 [1,2,7,6,4]이면, [1,2,4]를 이용해서 7을 만들 수 있고 [1,4,6]을 이용해서 11을 만들 수 있고 [2,4,7]을 이용해서 13을 만들 수 있고 [4,6,7]을 이용해서 17을 만들 수 있으므로 4를 반환한다.'''

#4) 코드 설명

'''solution 함수에서 nums의 값을 입력 받는다.
개수를 세기 위해 answer은 초기 값을 0으로 준다.
반복문들을 통해 i는 0부터 nums의 길이 빼기까지 1씩 증가하고 j는 해당 i 값 더하기 1부터 nums의 길이 빼기 2까지 1씩 증가하고 k는 해당 j 값 더하기 1부터 nums의 길이 빼기 1까지 1씩 증가시켜서 nums 리스트의 중복없이 모든 3자리 수를 더한 경우의 수를 찾는다.
모든 경우의 수는  마지막 반복문을 통해 2부터 해당 i, j, k의 위치의 값들은 더한 값 빼기 1까지 q에 1씩 증가시켜 만약 해당 i, j, k의 위치의 값들을 더한 값을 q로 나누었을 때 0이 나오면 소수가 아닌게 되므로 break를 통해 빠져나간다.
그렇지 않으면 소수이므로 answer의 값을 1 증가시킨다.
사중 반복문을 통해 모든 경우의 수를 확인하여 모든 반복문이 종료가 되면 answer 값을 반환한다.'''

#문제 출처 : 프로그래머스
