import string

a = string.ascii_letters


def solution(s, n):
    s = list(s)
    for i in range(len(s)):
        if s[i] in a:
            b = a.index(s[i])
            if b < 26 and b + n > 25:
                s[i] = a[b + n - 26]
            elif b > 25 and b + n > 51:
                s[i] = a[b + n - 26]
            else:
                s[i] = a[b + n]
    answer = "".join(s)
    return answer


# 1. 문제

# 1) 문제 설명

'어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 한다. 예를 들어 "AB"는 1만큼 밀면 "BC"가 되고, 3만큼 밀면 "DE"가 된다. "z"는 1만큼 밀면 "a"가 된다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해라.'

# 2) 제한 사항

"""공백은 아무리 밀어도 공백이다.
s는 알파벳 소문자, 대문자, 공백으로만 이루어져 있다.
s의 길이는 8000이하이다.
n은 1 이상, 25이하인 자연수이다."""

# 3) 입출력 예시

"""입출력 예 #1

s가 "AB"이고 n이 1이면 "BC"가 출력된다.
입출력 예 #2

s가 "z"이고 n이 1이면 "a"가 출력된다.
입출력 예 #3

s가 "a B z"이고 n이 4이면 "e F d"가 출력된다."""

# 4) 코드 설명

"""알파벳 대소문자를 사용하기 위해 string 모듈을 불러온다.﻿
알파벳 대소문자를 저장하기 위해 ascii_letters를 사용하여 a에 저장한다.
solution 함수에서 s와 n의 값을 입력 받는다.
문자열 s를 리스트 형태로 바꾼다.
만약 리스트 안의 요소가 a 안에 있다면, s[i]가 대문자나 소문자라는 의미이므로 a에서 해당 위치의 값을 찾아 b에 저장한다. 
그 후 b의 값이 만약 26보다 작고 b + n의 값이 25보다 크다면, 즉 s[i]가 소문자이고 일정한 거리를 밀었을 때 그 값이 소문자 z를 넘어간다면 해당 s[i]는 a[b+n - 26]을 해서 소문자 a 위치부터 다시 밀어지게 한다.
만약 b의 값이 26보다 크고 b+n의 값이 51보타 크다면, 즉 s[i]가 대문자이고 일정한 거리를 밀었을 때 그 값이 대문자 z를 넘어간다면 해당 s[i]는 a[b+n - 26]을 해서 대문자 A 위치부터 다시 밀어지게 한다.
만약 두 경우 모두 아니라면 s[i]는 a[b+n]을 해준다.
5~8번째 과정을 반복문을 통해 리스트 s의 길이만큼 반복한다.
반복문이 끝나면 해당 리스트를 join 함수를 이용하여 다시 문자열로 만들어 반환한다."""

# 문제 출처 : 프로그래머스
